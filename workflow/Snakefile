configfile: "config.yaml"

import os

rule all:
    input:
        expand("results/{callset}/combined_variants.tsv", callset=[cs['id'] for cs in config["callsets"]])

rule truvari_ga4gh:
    input:
        lambda wildcards: next(cs['bench_dir'] for cs in config["callsets"] if cs["id"] == wildcards.callset)
    output:
        query_vcf="results/ga4gh/{callset}/query.vcf.gz",
        truth_vcf="results/ga4gh/{callset}/truth.vcf.gz"
    conda:
        "envs/truvari.yml"
    log:
        "logs/{callset}/truvari_ga4gh.log"
    shell:
        """
        truvari ga4gh \
            --with-refine -B 0 \
            -i {input} \
            -o results/ga4gh/{wildcards.callset} \
            &> {log}
        """

rule get_FPandFN_vcf:
    input:
        query_vcf="results/ga4gh/{callset}/query.vcf.gz",
        truth_vcf="results/ga4gh/{callset}/truth.vcf.gz"
    output:
        fn_vcf="results/ga4gh/{callset}/fn.vcf.gz",
        fp_vcf="results/ga4gh/{callset}/fp.vcf.gz"
    conda:
        "envs/bcftools.yml"
    log:
        "logs/{callset}/get_FPandFN.log"
    shell:
        """
        echo "Extracting FNs" > {log}
        bcftools view -Oz \
            -o {fn_vcf} \
            --include 'FMT/BD=="FN"' \
            {input.truth_vcf} \
            &> {log}
        
        echo "Extracting FPs" >> {log}
        bcftools view -Oz \
            -o {fp_vcf} \
            --include 'FMT/BD=="FP"' \
            {input.query_vcf} \
            &>> {log}
        """

rule truvari_anno:
    input:
        vcf="results/{callset}/{type}_vcf"
    output:
        anno_vcf="results/{callset}/anno_{type}.vcf"
    conda:
        "envs/truvari.yaml"
    log:
        "logs/{callset}/truvari_anno_{type}.log"
    params:
        svinfo_params="",  # Add specific parameters for svinfo
        trf_params=""  # Add specific parameters for trf
    shell:
        """
        truvari anno svinfo {params.svinfo_params} {input.vcf} | \
        truvari anno trf {params.trf_params} -o {output.anno_vcf} &> {log}
        """

rule bcftools_query:
    input:
        vcf="results/{callset}/anno_{type}.vcf"
    output:
        tsv="results/{callset}/{type}_variants.tsv"
    conda:
        "envs/bcftools.yaml"
    log:
        "logs/{callset}/bcftools_query_{type}.log"
    shell:
        """
        bcftools query -f '%CHROM\t%POS\t%ID\t%REF\t%ALT\t%SVTYPE\t%SVLEN\n' {input.vcf} > {output.tsv} &> {log}
        """

rule r_subsample_variants:
    input:
        fp_tsv="results/{callset}/fp_variants.tsv",
        fn_tsv="results/{callset}/fn_variants.tsv"
    output:
        subsampled_tsv="results/{callset}/subsampled_variants.tsv",
        bed="results/{callset}/variants.bed"
    conda:
        "envs/r-tidyverse.yaml"
    log:
        "logs/{callset}/r_subsample_variants.log"
    params:
        num_variants=config["parameters"]["num_variants"],
        seed=lambda wildcards: next(cs['random_seed'] for cs in config["callsets"] if cs["id"] == wildcards.callset)
    script:
        "scripts/subsample_variants.R"

rule download_chain_file:
    output:
        chain=config["chain_file"]
    log:
        "logs/download_chain_file.log"
    shell:
        """
        wget {output.chain} &> {log}
        """

rule liftover_maternal:
    input:
        bed="results/{callset}/variants.bed",
        chain=config["chain_file"]
    output:
        lifted_bed="results/{callset}/lifted_variants_maternal.bed",
        unmapped="results/{callset}/unmapped_maternal.bed"
    conda:
        "envs/liftover.yaml"
    log:
        "logs/{callset}/liftover_maternal.log"
    shell:
        """
        liftOver {input.bed} {input.chain} {output.lifted_bed} {output.unmapped} &> {log}
        """

rule liftover_paternal:
    input:
        bed="results/{callset}/variants.bed",
        chain=config["chain_file"]
    output:
        lifted_bed="results/{callset}/lifted_variants_paternal.bed",
        unmapped="results/{callset}/unmapped_paternal.bed"
    conda:
        "envs/liftover.yaml"
    log:
        "logs/{callset}/liftover_paternal.log"
    shell:
        """
        liftOver {input.bed} {input.chain} {output.lifted_bed} {output.unmapped} &> {log}
        """

rule combine_results:
    input:
        subsampled_tsv="results/{callset}/subsampled_variants.tsv",
        lifted_maternal="results/{callset}/lifted_variants_maternal.bed",
        lifted_paternal="results/{callset}/lifted_variants_paternal.bed"
    output:
        combined="results/{callset}/combined_variants.tsv"
    log:
        "logs/{callset}/combine_results.log"
    shell:
        """
        paste {input.subsampled_tsv} > temp_combined.tsv
        echo -e '\\nMaternal Assembly:' >> temp_combined.tsv
        cat {input.lifted_maternal} >> temp_combined.tsv
        echo -e '\\nPaternal Assembly:' >> temp_combined.tsv
        cat {input.lifted_paternal} >> temp_combined.tsv
        mv temp_combined.tsv {output.combined} &> {log}
        """